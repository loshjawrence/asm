/**************************************
 * ep2 registers
 *************************************/
8086 registers:
    * Naming similar to x86 x64 registers)
    * 8086 was a 16 bit cpu.

//////////////////////////////////////
General purpose regs: ax bx cx and dx.
each of these also had 2 8 bit versions of the register
fox example ax had ah and al (i.e. hi and low)
* if you want to change bx the compiler expects that it is back to the orig value before you function leaves
* so you must push rbx at the top and pop rbx at the bottom before ret
/////////////////////////////////////

/////////////////////////////////////
index regs: si di bp and sp
source , dest , base pointer, and stack pointer
/////////////////////////////////////

/////////////////////////////////////
instruction pointer: ip
/////////////////////////////////////

/////////////////////////////////////
segment registers: cs ds es and ss
memory was segmented back then and these were used for that paradigm.
not really used.
/////////////////////////////////////

/////////////////////////////////////
flags register: flags
stores the state of comparisons, carry, etc
/////////////////////////////////////

/**************************************
 * ep3 x86 x64 registers
 *************************************/
 Naming conventions of above are extended to 32 bit registers
 It is the same name but with an e prefix. the older registers are just
 the lsb portions of register
 x64 registers are again the same register names as the 16bit versions but with an r prefix for the full 64 bits.
 x64 also adds access to the lowest byte in the other registers to make things consistant.
 so for the old 8086 registers they all have a L suffix to access the lowest byte
 so al, bl, cl, dl, sil, dil, spl, bpl.
 the new x64 registers R8-R15 have 32 16 and 8 bit aliases
 the 32 alias end with d(double word or dword) the 16 bit end with w(word) and the 8 bit end with b(byte)
 the ip register has only EIP(32 bit) and RIP(64 bit) alias
 the flags register has rflags, eflags and flags for 64, 32, 16 bit aliases

so all in all it should look like:
a,b,c, and d also have the old 8086 way of accessing the upper bits of the 16 bit section
i.e. ah, bh, ch, dh
|RAX            |EAX      |AX  |AL  |
|RBX            |EBX      |BX  |BL  |
|RCX            |ECX      |CX  |CL  |
|RDX            |EDX      |DX  |DL  |
|RSI            |ESI      |SI  |SIL |
|RDI            |EDI      |DI  |DIL |
|RSP            |ESP      |SP  |SPL |
|RBP            |EBP      |BP  |BPL |
|RIP            |EIP                |
|R8             |R8D      |R8W |R8B |
|R9             |R9D      |R9W |R9B |
|R10            |R10D     |R10W|R10B|
|R11            |R11D     |R11W|R11B|
|R12            |R12D     |R12W|R12B|
|R13            |R13D     |R13W|R13B|
|R14            |R14D     |R14W|R14B|
|R15            |R15D     |R15W|R15B|
|RFlags         |EFlags             |

NOTE: using 32bit regs with 32bit instructions (on x64 hw) zeros the top 32 bits of the register.
however the 16 and 8 bit instructions do not zero the upper msb's

/**************************************
 * ep4 Fundamental data types
 *************************************/
 integers: byte, word, dword, qword
 floating point: real4, real8, real10
 simd pointers: xmmword, ymmword, zmmword

signed and unsigned comes down to which instructions you use.
its really up to the programmer to keep track of what data is intended to be signed
example: unsigned: div and mul, signed: idiv  and imul
for other instructions like add and sub theres no difference
 x86 is designed to use 2s comp when doing signed arith
to get the pos version of a signed number, flip the bits and add 1

===============
Floating point
real4: 32 bits: 1 sign, 8 exp, 23 mantissa
real8: 64 bits: 1 sign, 11 exp, 52 mantissa
real10: 80 bits: 1 sign, 15 exp, 64 bit mantissa.
===============

