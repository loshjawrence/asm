/**************************************
 * ep2 registers
 *************************************/
8086 registers:
    * Naming similar to x86 x64 registers)
    * 8086 was a 16 bit cpu.

//////////////////////////////////////
General purpose regs: ax bx cx and dx.
each of these also had 2 8 bit versions of the register
fox example ax had ah and al (i.e. hi and low)
* if you want to change bx the compiler expects that it is back to the orig value before you function leaves
* so you must push rbx at the top and pop rbx at the bottom before ret
/////////////////////////////////////

/////////////////////////////////////
index regs: si di bp and sp
source , dest , base pointer, and stack pointer
/////////////////////////////////////

/////////////////////////////////////
instruction pointer: ip
/////////////////////////////////////

/////////////////////////////////////
segment registers: cs ds es and ss
memory was segmented back then and these were used for that paradigm.
not really used.
/////////////////////////////////////

/////////////////////////////////////
flags register: flags
stores the state of comparisons, carry, etc
/////////////////////////////////////

/**************************************
 * ep3 x86 x64 registers
 *************************************/
 Naming conventions of above are extended to 32 bit registers
 It is the same name but with an e prefix. the older registers are just
 the lsb portions of register
 x64 registers are again the same register names as the 16bit versions but with an r prefix for the full 64 bits.
 x64 also adds access to the lowest byte in the other registers to make things consistant.
 so for the old 8086 registers they all have a L suffix to access the lowest byte
 so al, bl, cl, dl, sil, dil, spl, bpl.
 the new x64 registers R8-R15 have 32 16 and 8 bit aliases
 the 32 alias end with d(double word or dword) the 16 bit end with w(word) and the 8 bit end with b(byte)
 the ip register has only EIP(32 bit) and RIP(64 bit) alias
 the flags register has rflags, eflags and flags for 64, 32, 16 bit aliases

so all in all it should look like:
a,b,c, and d also have the old 8086 way of accessing the upper bits of the 16 bit section
i.e. ah, bh, ch, dh
|RAX            |EAX      |AX  |AL  |
|RBX            |EBX      |BX  |BL  |
|RCX            |ECX      |CX  |CL  |
|RDX            |EDX      |DX  |DL  |
|RSI            |ESI      |SI  |SIL |
|RDI            |EDI      |DI  |DIL |
|RSP            |ESP      |SP  |SPL |
|RBP            |EBP      |BP  |BPL |
|RIP            |EIP                |
|R8             |R8D      |R8W |R8B |
|R9             |R9D      |R9W |R9B |
|R10            |R10D     |R10W|R10B|
|R11            |R11D     |R11W|R11B|
|R12            |R12D     |R12W|R12B|
|R13            |R13D     |R13W|R13B|
|R14            |R14D     |R14W|R14B|
|R15            |R15D     |R15W|R15B|
|RFlags         |EFlags             |

NOTE: using 32bit regs with 32bit instructions (on x64 hw) zeros the top 32 bits of the register.
however the 16 and 8 bit instructions do not zero the upper msb's

/**************************************
 * ep4 Fundamental data types
 *************************************/
 integers: byte, word, dword, qword
 floating point: real4, real8, real10
 simd pointers: xmmword, ymmword, zmmword

signed and unsigned comes down to which instructions you use.
its really up to the programmer to keep track of what data is intended to be signed
example: unsigned: div and mul, signed: idiv  and imul
for other instructions like add and sub theres no difference
 x86 is designed to use 2s comp when doing signed arith
to get the pos version of a signed number, flip the bits and add 1

===============
Floating point
real4: 32 bits: 1 sign, 8 exp, 23 mantissa
real8: 64 bits: 1 sign, 11 exp, 52 mantissa
real10: 80 bits: 1 sign, 15 exp, 64 bit mantissa.
===============

/**************************************
 * ep5 mov and lea(load effective addr)
 *************************************/
mov supports an imm64
 mov dst, src
 for move the src can be an immediate or a register
 but dst and src must be the same size. both cannot be "memory" i.e. a .data segment variable
 dst must be memory or a reg

 can use mov as a multibyte nop (nop is only 1 byte instruction)
 mov rax, rax is a 3 byte nop
 mov al, al is a 2 byte nop

lea is acutally an arith instr, it computes an SIB addr
lea does not change any flags.
in the .data section your variables are actually pointers to ram addresses
so to move the ram address it points to to a reg
you can't use mov since it move the data stored at the address.
you need lea to move the ram address to a reg.
once the ram address is in a reg you can move data to that address indirectly
see moveToRAMAddr in asm.asm

/**************************************
 * ep6 basic arith instr (add sub inc dec)
 *************************************/
signed carry is on overflow flag, unsiged carry is on carry flag

flags they affect: overflow carry sign zero, aux carry, parity
LOCK is supported
The 32 bit versions of add generates more efficient machine code than 64 bit.
64bit versions add an rex prefix in machine code.
can use 'add reg, 0' to update the flags according to reg without changing its value
similar to `and reg, reg` and `or reg, reg`.

`cmp reg, reg` sets the same flags as `sub reg, reg` since that's essentially what it's doing

`add reg, 1` if you need `inc reg` but also need the carry flag.

add is faster than mul. if you need to double a reg use `add reg, reg`. usually you would use shifts.

There is no `add reg64 imm64`. if the reg is 64bits then the immediate sign is extended

for sub, overflow flag is for signed borrow and carry flag is unsigned borrow.
flags: same as add

sub sign extends imm32s, if you need to subtract a imm64 you need to use mov first.

quick way to zero is `sub reg, reg` but `xor reg, reg` is used for this purpose.
can use add and sub to perform a swap, similar to xor swap, but just use xchg since faster and easier to read.

dec, like inc, doesnt set carry flag but it will set the zero flag. useful for loops if you want to know if they wrapped around
on their counter but leave the carry flags for the arith in the loop block.

/**************************************
 * ep7 bool (and or not xor)
 *************************************/
 to mark a number as binary in stick a b on the end
 01001111b
 xor is similar to asking which bits are not equal or where do i have an odd number of bits
 xnor is similar to asking which bits are equal or where do i have an even number of bits
 for xnor simply not the result of xor.

 or is similar to asking where are there 1's
 nor is similar to asking where do i have only 0's
 for nor simply not the result of or.

 and is similar to asking where are there only 1's
 nand is simliar to asking where are there not only 1's
 for nand simply not the result of and.

 nand and nor are universal gates, can make anything out of them.

 if you want to check if a reg is 0 do `and reg, reg` then check the zero flag


/**************************************
 * ep8 shift rotate and bit manip
 *************************************/
shl, shr, sal, sar, rol, ror, rcl, rcr, shld, shrd

shl is shift left
shr is shift right
the carry flag holds the bit that was shifted out
if the immediate is 1 the the overflow flag is set if the sign changed
can shift by a variable amount but only if using cl:
mov cl, 5
shl edx, cl
if you want to mul or div by a pow2 then you can use shifts but the value in the reg must be unsigned

but..
sal sar are arith shifts which preserve the sign bit and prevents the shifts from stepping on it.
sar with shift the sign bit into spots on the right of the sign bit to keep the math correcct.
shl and sal are the same instruction, i.e. the same behavior, also the same byte code if looking at the disassembly

rotates have similar special behavior to shifts (variable use of cl) and when imm is 1 the overflow flags are used

rcl rcr are "rotate through the carry flag" instructions, so it uses teh carry flag as an extra msb bit for the register
shld shlr are double precision shifts. its a 3 opperand instruction example:
shrd rax, rbx, 12
rax is the msb portion and rbx is the lsb portion and the whole thing is shifted right by 12 and the msb portion of the result
is saved in rax. rbx is unchanged after the instruction.

/**************************************
 * ep9 flags pushfq popfq pushf, popf
 *************************************/
flags register:
  15 | 14 | 13 | 12 | 11 | 10 |  09 | 08 | 07 | 06 | 05 | 04 | 03 | 02 | 01 | 00 |
     | NT |   IOPL  | OF | DF |  IF | TF | SF | ZF |    | AF |    | PF |    | CF |
NOTE: not all instr set the various flags
CF - carry flag, when theres an unsigned overflow, inc doesnt change this
PF - parity flag, 1 if even num of bits i.e xnor, not really used anymore
AF - aux carry flag, have due to back compat, overflow on low 4 bits of result
ZF - zero flag, when result is 0
SF - sign flag, 1 is neg 0 is pos
TF - trap flag, allows debuggers to step through code
IF - interrupt flag, allows interrupts to be called
DF - direction flag, 0 counting up in ram, 1 counting down in ram, for string instr. NOTE: UP in msvc
OF - overflow flag, signed overflow, overflow on 2nd highest msb, inc does change this
IOPL - shows IO port privilege level
NT - nested stask, shows if this task is nested
CPUID - if you can toggle bit 21, then the cpu is capable of the cpuid instr
pushfq ; push the rflags reg onto the stack
; you can then store it in rax with:
pop rax
; you can then change rax however you want
; then you can get the value back to the rflags reg with:
push rax ; put our changed flags on the stack
popfq ; take off the stack and put into the flags reg

NOTE: An overflow happens when you carry from the second highest bit to the highest bit of a signed integer, for example from bit 6 to bit 7 in a byte.
Adding 3 to 126 will result in an overflow.. instead of the expected result of 129, you will get -127 (10000001).

/**************************************
 * ep10 conditional jump mov byteset
 *************************************/
bascially they move,jump,set if true nothing otherwise
jump versions: (NOTE there are mov and set versions of these as well)
NOTE: cmov's will clear the upper part of 64bit regs
NOTE: signed uses equal/not equal and unsigned uses above/below.
jo - overflow
jno - not overflow
jb/jc/jnae - carry unsigned
jnb/jnc/jae - not carry unsigned
je/jz - zero
jne/jnz - not zero
jbe/jna - blow or equal unsigned
jnbe/ja - above signed
js - sign
jns - not sign
jp/jpe - parity even (even num 1s)
jnp/jpo - parity odd (odd num 1s)
jl/jnge - less signed
jnl/jge - not less signed
jle/jng - not greater signed
jnle/jg - greater signed

/**************************************
 * ep11 conditional jump mov byteset
 *************************************/
div reg/mem
NOTE: other operand implied, example: 50 / 10 would be
mov ax, 50
mov cl, 10
div cl ; ax
; byte divide result al, remainder ah
NOTE:
; 16 bit divide result ax, remainder dx
; 32 bit result eax, remainder edx
; 64 bit result rax, remainder rdx


/**************************************
 * ep12 param passing in Windows C calling convention
 *************************************/

